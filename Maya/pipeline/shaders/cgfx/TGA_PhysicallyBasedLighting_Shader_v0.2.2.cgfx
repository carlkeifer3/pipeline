/*
TGA Physically Based Lighting CGFX Realtime Shader for Maya

Current Version:
v0.2.2
2011-10-11

By Kostas Gialitakis & Niklas Hansson
www.thegameassembly.com

----Change Log----

From 0.2.1 to 0.2.2:
-Fixed a bug with how reflections were handled in conjunction with a normal map.

*/

/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 * Fx_code_generator build 45261.50496 23 Jul 2009 nt-x86
 *                                                                            *
 * Portions Copyright (c) 1986-2009 mental images GmbH, Berlin, Germany.      *
 ******************************************************************************/

// shader type surface

//
// The state structure is used internally within the fragment shader to
// commonly used values.
//
struct State
{
	float4 tex_coord[4];
	float3 position;
	float3 origin;
	float3 normal;
	float3 geom_normal;
	float3 direction;
	float ray_length;
	float3x3 tangent_space[1];
};

//
// Values for the light_type parameter of light shaders
//
#define LIGHT_POINT    0
#define LIGHT_SPOT     1
#define LIGHT_INFINITE 2
#define LIGHT_PLANAR   3

//
// The light iterator structure holds the return values resulting from
// evaluating a light.
//
#ifndef __LIGHT_ITERATOR_STRUCT
#define __LIGHT_ITERATOR_STRUCT
struct Light_iterator {
    float3 msl_point;
    float4 msl_contribution;
    float4 msl_raw_contribution;
    float  msl_dot_nl;
    float3 msl_direction;
    float  msl_distance;
    float4 msl_shadow;
    int    msl_count;
};
#endif // __LIGHT_ITERATOR_STRUCT

struct Ray {
    float3 msl_origin;
    float3 msl_direction;
};

void __make_basis(const float3 n, const float3 u, const float3 v,
        out float3 t, out float3 b)
{
    b = normalize(cross(u,n));
    t = cross(n,b);
    if (dot(b,v) < 0.0)  b = -b;
}

float3 __perspective_divide(float4 pt)
{
    return pt.xyz/pt.w;
}

// 
// State dependant variable recalculation. 
// 
void __update_state_origin_or_position(inout State state) 
{ 
    state.direction = state.position - state.origin; 
    state.ray_length = length(state.direction); 
    state.direction = normalize(state.direction); 
} 

//
// The following are free parameters of the shader that should be set by the
// application at runtime.
//

texture __msl_TGA_PhysicallBasedLighting_Shader_1_AlbedoTexture <
	string UIName = "msl_TGA_PhysicallBasedLighting_Shader_1_AlbedoTexture";
	string ResourceType = "2D";
>;

sampler2D Albedo_Texture_Gamma = sampler_state {
	Texture = <__msl_TGA_PhysicallBasedLighting_Shader_1_AlbedoTexture>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};

texture __msl_TGA_PhysicallBasedLighting_Shader_1_NormalTexture <
	string UIName = "msl_TGA_PhysicallBasedLighting_Shader_1_NormalTexture";
	string ResourceType = "2D";
>;

sampler2D Normal_Texture_Linear = sampler_state {
	Texture = <__msl_TGA_PhysicallBasedLighting_Shader_1_NormalTexture>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};

texture __msl_TGA_PhysicallBasedLighting_Shader_1_AOTexture <
	string UIName = "msl_TGA_PhysicallBasedLighting_Shader_1_AOTexture";
	string ResourceType = "2D";
>;

sampler2D AO_Texture_Gamma = sampler_state {
	Texture = <__msl_TGA_PhysicallBasedLighting_Shader_1_AOTexture>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};

texture __msl_TGA_PhysicallBasedLighting_Shader_1_RoughnessTexture <
	string UIName = "msl_TGA_PhysicallBasedLighting_Shader_1_RoughnessTexture";
	string ResourceType = "2D";
>;

sampler2D Roughness_Texture_Gamma = sampler_state {
	Texture = <__msl_TGA_PhysicallBasedLighting_Shader_1_RoughnessTexture>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};

texture __msl_TGA_PhysicallBasedLighting_Shader_1_SubstanceTexture <
	string UIName = "msl_TGA_PhysicallBasedLighting_Shader_1_SubstanceTexture";
	string ResourceType = "2D";
>;

sampler2D Substance_Texture_Gamma = sampler_state {
	Texture = <__msl_TGA_PhysicallBasedLighting_Shader_1_SubstanceTexture>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};

texture __msl_Environment_map_cubic_mip_1_env_tex <
	string UIName = "msl_Environment_map_cubic_mip_1_env_tex";
	string ResourceType = "Cube";
>;

samplerCUBE Environment_Cube_Gamma = sampler_state {
	Texture = <__msl_Environment_map_cubic_mip_1_env_tex>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
	WrapR = ClampToEdge;
	WrapS = ClampToEdge;
	WrapT = ClampToEdge;
};

float Ambient_Mip_Level
<
> = 6;

float Reflection_Max_Mip_Level
<
> = 8;

/*
float msl_TGA_PhysicallBasedLighting_Shader_1_Environment_Intensity
<
	float UIMin = 0.0;
	float UIMax = 1.0;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;
*/

float Exposure
<
	float UIMin = 0.0;
	float UIMax = 1.0;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;



////////////////////////// Directional1

float3 msl_Light_directional_1_color: Diffuse
<
	string UIName = "Directional1 Color";
	float4 UIMin = float4(0.0, 0.0, 0.0, 0.0);
	float4 UIMax = float4(1.0, 1.0, 1.0, 1.0);
	float UIStep = 0.01;
	string UIWidget = "slider";
> = float3(1.0, 1.0, 1.0);

float msl_Light_directional_1_intensity
<
	string UIName = "Directional1 Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;

float3 Directional1_Direction : Direction 
<
	string Object = "InfiniteLight0";
	string Space = "View";
> = float3(0.0, 0.0, -1.000000);
float4x4 msl_light0_transform_internal_to_light;
float4x4 msl_light0_transform_light_to_internal;



////////////////////////// Directional2

float3 msl_Light_directional_2_color: Diffuse
<
	string UIName = "Directional2 Color";
	float4 UIMin = float4(0.0, 0.0, 0.0, 0.0);
	float4 UIMax = float4(1.0, 1.0, 1.0, 1.0);
	float UIStep = 0.01;
	string UIWidget = "slider";
> = float3(1.0, 1.0, 1.0);

float msl_Light_directional_2_intensity
<
	string UIName = "Directional2 Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float3 Directional2_Direction : Direction 
<
	string Object = "InfiniteLight1";
	string Space = "View";
> = float3(0.0, 0.0, -1.000000);
float4x4 msl_light1_transform_internal_to_light;
float4x4 msl_light1_transform_light_to_internal;



////////////////////////// Directional3

float3 msl_Light_directional_3_color: Diffuse
<
	string UIName = "Directional3 Color";
	float4 UIMin = float4(0.0, 0.0, 0.0, 0.0);
	float4 UIMax = float4(1.0, 1.0, 1.0, 1.0);
	float UIStep = 0.01;
	string UIWidget = "slider";
> = float3(1.0, 1.0, 1.0);

float msl_Light_directional_3_intensity
<
	string UIName = "Directional3 Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float3 Directional3_Direction : Direction 
<
	string Object = "InfiniteLight2";
	string Space = "View";
> = float3(0.0, 0.0, -1.000000);
float4x4 msl_light2_transform_internal_to_light;
float4x4 msl_light2_transform_light_to_internal;



////////////////////////// Point1

float3 msl_Light_point_1_color: Diffuse
<
	string UIName = "Point1 Color";
	string UIWidget = "Color";
> = float3(1.0, 1.0, 1.0);

float msl_Light_point_1_intensity
<
	string UIName = "Point1 Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float msl_Light_point_1_distance_falloff_exponent
<
	string UIName = "Point1 Dist Falloff Exponent";
	float UIMin = 0.0;
	float UIMax = 4.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float msl_Light_point_1_distance_scale
<
	string UIName = "Point1 Distance Scale";
	float UIMin = 0.001000;
	float UIMax = 2.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;

float3 Point1_Position : Position 
<
	string Object = "PointLight3";
	string Space = "View";
> = float3(0.0, 0.0, 0.0);
float4x4 msl_light3_transform_internal_to_light;
float4x4 msl_light3_transform_light_to_internal;



////////////////////////// Point2

float3 msl_Light_point_2_color: Diffuse
<
	string UIName = "Point2 Color";
	string UIWidget = "Color";
> = float3(1.0, 1.0, 1.0);

float msl_Light_point_2_intensity
<
	string UIName = "Point2 Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float msl_Light_point_2_distance_falloff_exponent
<
	string UIName = "Point2 Dist Falloff Exponent";
	float UIMin = 0.0;
	float UIMax = 4.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float msl_Light_point_2_distance_scale
<
	string UIName = "Point2 Distance Scale";
	float UIMin = 0.001000;
	float UIMax = 2.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;

float3 Point2_Position : Position 
<
	string Object = "PointLight4";
	string Space = "View";
> = float3(0.0, 0.0, 0.0);
float4x4 msl_light4_transform_internal_to_light;
float4x4 msl_light4_transform_light_to_internal;



////////////////////////// Point3

float3 msl_Light_point_3_color: Diffuse
<
	string UIName = "Point3 Color";
	string UIWidget = "Color";
> = float3(1.0, 1.0, 1.0);

float msl_Light_point_3_intensity
<
	string UIName = "Point3 Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float msl_Light_point_3_distance_falloff_exponent
<
	string UIName = "Point3 Dist Falloff Exponent";
	float UIMin = 0.0;
	float UIMax = 4.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float msl_Light_point_3_distance_scale
<
	string UIName = "Point3 Distance Scale";
	float UIMin = 0.001000;
	float UIMax = 2.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;

float3 Point3_Position : Position 
<
	string Object = "PointLight5";
	string Space = "View";
> = float3(0.0, 0.0, 0.0);
float4x4 msl_light5_transform_internal_to_light;
float4x4 msl_light5_transform_light_to_internal;


//
// The following are parameters representing non-varying state variables 
// referenced by the shader. These should be set by the application at runtime.
// Note that vector parameters should be provided in camera space.
//
float4x4 __object_to_ndc : WorldViewProjection
<
	string UIWidget = "none";
>;
//float __refracted_ior = 1.01;
//float __incident_ior = 1.0;
//bool __orthographic : Orthographic= false;
float4x4 __world_to_camera : View
<
	string UIWidget = "none";
>;
float4x4 __object_to_world : World
<
	string UIWidget = "none";
>;
float4x4 __object_to_camera : WorldView
<
	string UIWidget = "none";
>;
float4x4 __camera_to_world : ViewInverse
<
	string UIWidget = "none";
>;
float4x4 __camera_to_object : WorldViewInverse
<
	string UIWidget = "none";
>;
//                                                   
// The following are parameters representing non-varying non-state variables      
// referenced by the shader. These should be set by the application at runtime.             
//                                                   
float4x4 __internal_to_light;
float4x4 __light_to_internal;



//
// The App2vert structure defines the vertex attributes used by the vertex
// shader. The application should supply a vertex stream containing these 
// elements.
//
struct App2vert
{
	float3 position : POSITION;
	float3 normal : NORMAL;
	float4 texcoord0 : TEXCOORD0;
	float4 texcoord1 : TEXCOORD1;
	float4 texcoord2 : TEXCOORD2;
	float4 texcoord3 : TEXCOORD3;
	float3 tex_du : TANGENT;
	float3 tex_dv : BINORMAL;
};

//
// The Vert2frag structure defines values used by the fragment shader and
// supplied by the vertex shader.
//
struct Vert2frag
{
	float4 hpos : POSITION;
	float4 tex_coord[4] : TEXCOORD0;
	float3 tex_du : TEXCOORD4;
	float3 tex_dv : TEXCOORD5;
	float3 position : TEXCOORD6;
	float3 normal : TEXCOORD7;
};

//
// This function is the main method of the vertex shader.
//
Vert2frag vertex_main(
	App2vert vs_in)
{
	Vert2frag vs_out;
	float4 position = float4(vs_in.position, 1);
	vs_out.hpos = mul(__object_to_ndc, position);
	vs_out.position = mul(__object_to_camera, position).xyz;
	vs_out.normal = mul(vs_in.normal, (float3x3)__camera_to_object);
	vs_out.tex_coord[0] = vs_in.texcoord0;
	vs_out.tex_coord[1] = vs_in.texcoord1;
	vs_out.tex_coord[2] = vs_in.texcoord2;
	vs_out.tex_coord[3] = vs_in.texcoord3;
	vs_out.tex_du = mul((float3x3)__object_to_camera, vs_in.tex_du);
	vs_out.tex_dv = mul((float3x3)__object_to_camera, vs_in.tex_dv);
	return vs_out;
}

//
// Declaration of final output type. For MRT, this is a struct.
//
typedef float4 FS_OUT;

//
// The following functions are generated from the MetaSL implementation of
// the shaders that are part of the compiled shader graph.
//

void TGA_PhysicallBasedLighting_Shader_Conversion_float_to_color_main(
	inout State state,
	float msl_scalar,
	out float4 msl_color)
{
	{
		msl_color = (float4(msl_scalar, msl_scalar, msl_scalar, 1.0));
	}
}

void TGA_PhysicallBasedLighting_Shader_Inputs_Ext_texture_lookup_2d_alpha_main(
	inout State state,
	sampler2D msl_texture,
	float2 msl_texture_uv,
	out float4 msl_result,
	out float msl_alpha)
{
	{
		msl_result = (tex2D(msl_texture, msl_texture_uv));
		msl_alpha = msl_result.a;
	}
}

void TGA_PhysicallBasedLighting_Shader_Inputs_Conversion_float_to_color_main(
	inout State state,
	float msl_scalar,
	out float4 msl_color)
{
	{
		msl_color = (float4(msl_scalar, msl_scalar, msl_scalar, 1.0));
	}
}

void TGA_PhysicallBasedLighting_Shader_Inputs_Math_color_pow_main(
	inout State state,
	float4 msl_base,
	float4 msl_exponent,
	out float4 msl_result)
{
	{
		msl_result = (float4((pow((float4(msl_base)), (float4(msl_exponent))))));
	}
}

void TGA_PhysicallBasedLighting_Shader_Inputs_Normals_make_normal_main(
	inout State state,
	float4 msl_color,
	float msl_amount,
	out float3 msl_result)
{
	{
		float3 msl_n = (msl_color.xyz - 0.5) * 2.0;
		msl_n.xy *= msl_amount;
		msl_result = (normalize((mul(msl_n, (state.tangent_space)[0]))));
	}
}

void TGA_PhysicallBasedLighting_Shader_Inputs_Conversion_color_to_float_main(
	inout State state,
	float4 msl_color,
	out float msl_scalar)
{
	{
		msl_scalar = (((msl_color.r + msl_color.g) + msl_color.b) / 3.0);
	}
}

void TGA_PhysicallBasedLighting_Shader_Inputs_main(
	inout State state,
	sampler2D msl_AlbedoTexture,
	sampler2D msl_NormalTexture,
	sampler2D msl_AOTexture,
	sampler2D msl_RoughnessTexture,
	sampler2D msl_SubstanceTexture,
	out float4 msl_Albedo,
	out float3 msl_Normal,
	out float msl_AO,
	out float msl_Roughness,
	out float4 msl_Substance)
{
	{
		float4 msl_AlbedoGamma_RGB_result;
		float msl_AlbedoGamma_RGB_alpha;
		TGA_PhysicallBasedLighting_Shader_Inputs_Ext_texture_lookup_2d_alpha_main(state, msl_AlbedoTexture, (state.tex_coord)[0].xy, msl_AlbedoGamma_RGB_result, msl_AlbedoGamma_RGB_alpha);
		float4 msl_MyGamma_2_2_color;
		TGA_PhysicallBasedLighting_Shader_Inputs_Conversion_float_to_color_main(state, 2.200000, msl_MyGamma_2_2_color);
		float4 msl_AlbedoLinear_RGB_result;
		TGA_PhysicallBasedLighting_Shader_Inputs_Math_color_pow_main(state, msl_AlbedoGamma_RGB_result, msl_MyGamma_2_2_color, msl_AlbedoLinear_RGB_result);
		msl_Albedo = msl_AlbedoLinear_RGB_result;
		float4 msl_Normal_RGB_result;
		float msl_Normal_RGB_alpha;
		TGA_PhysicallBasedLighting_Shader_Inputs_Ext_texture_lookup_2d_alpha_main(state, msl_NormalTexture, (state.tex_coord)[0].xy, msl_Normal_RGB_result, msl_Normal_RGB_alpha);
		float3 msl_Normals_make_normal_1_result;
		TGA_PhysicallBasedLighting_Shader_Inputs_Normals_make_normal_main(state, msl_Normal_RGB_result, 1.0, msl_Normals_make_normal_1_result);
		msl_Normal = msl_Normals_make_normal_1_result;
		float4 msl_AOGamma_BW_result;
		float msl_AOGamma_BW_alpha;
		TGA_PhysicallBasedLighting_Shader_Inputs_Ext_texture_lookup_2d_alpha_main(state, msl_AOTexture, (state.tex_coord)[0].xy, msl_AOGamma_BW_result, msl_AOGamma_BW_alpha);
		float4 msl_AOLinear_BW_result;
		TGA_PhysicallBasedLighting_Shader_Inputs_Math_color_pow_main(state, msl_AOGamma_BW_result, msl_MyGamma_2_2_color, msl_AOLinear_BW_result);
		float msl_Conversion_color_to_float_1_scalar;
		TGA_PhysicallBasedLighting_Shader_Inputs_Conversion_color_to_float_main(state, msl_AOLinear_BW_result, msl_Conversion_color_to_float_1_scalar);
		msl_AO = msl_Conversion_color_to_float_1_scalar;
		float4 msl_RoughnessGamma_BW_result;
		float msl_RoughnessGamma_BW_alpha;
		TGA_PhysicallBasedLighting_Shader_Inputs_Ext_texture_lookup_2d_alpha_main(state, msl_RoughnessTexture, (state.tex_coord)[0].xy, msl_RoughnessGamma_BW_result, msl_RoughnessGamma_BW_alpha);
		float4 msl_RoughnessLinear_BW_result;
		TGA_PhysicallBasedLighting_Shader_Inputs_Math_color_pow_main(state, msl_RoughnessGamma_BW_result, msl_MyGamma_2_2_color, msl_RoughnessLinear_BW_result);
		float msl_Conversion_color_to_float_2_scalar;
		TGA_PhysicallBasedLighting_Shader_Inputs_Conversion_color_to_float_main(state, msl_RoughnessLinear_BW_result, msl_Conversion_color_to_float_2_scalar);
		msl_Roughness = msl_Conversion_color_to_float_2_scalar;
		float4 msl_SubstanceGamma_RGB_result;
		float msl_SubstanceGamma_RGB_alpha;
		TGA_PhysicallBasedLighting_Shader_Inputs_Ext_texture_lookup_2d_alpha_main(state, msl_SubstanceTexture, (state.tex_coord)[0].xy, msl_SubstanceGamma_RGB_result, msl_SubstanceGamma_RGB_alpha);
		float4 msl_SubstanceLinear_RGB_result;
		TGA_PhysicallBasedLighting_Shader_Inputs_Math_color_pow_main(state, msl_SubstanceGamma_RGB_result, msl_MyGamma_2_2_color, msl_SubstanceLinear_RGB_result);
		msl_Substance = msl_SubstanceLinear_RGB_result;
	}
}

void Light_directional_main(
	inout State state,
	float4 msl_color,
	float msl_intensity,
	out float4 msl_result,
	out float4 msl_light_shadow,
	inout float4x4 msl__state_transform_internal_to_light,
	inout float4x4 msl__state_transform_light_to_internal)
{
	{
		msl_result = (float4(((float4(msl_color)) * msl_intensity)));
		msl_light_shadow = (float4(1,1,1,1));
	}
}

void Light_directional_1_lightmain(
	inout State state,
	in float3 msl__state_light_position,
	in float3 msl__state_light_direction,
	in float4x4 msl__state_transform_internal_to_light,
	in float4x4 msl__state_transform_light_to_internal,
	out Light_iterator msl___light)
{
	float3 msl__state_light_to_surface = (state.position) - msl__state_light_position;
	float msl__state_light_distance = length(msl__state_light_to_surface);
	msl__state_light_to_surface /= msl__state_light_distance;
	float msl__state_light_dot_nl = dot((-msl__state_light_direction), (state.normal));
	float4 msl_Light_directional_1_result;
	float4 msl_Light_directional_1_light_shadow;
	Light_directional_main(state, float4(msl_Light_directional_1_color,1), msl_Light_directional_1_intensity, msl_Light_directional_1_result, msl_Light_directional_1_light_shadow, msl__state_transform_internal_to_light, msl__state_transform_light_to_internal);
	msl___light.msl_point = msl__state_light_position;
	msl___light.msl_direction = (-msl__state_light_direction);
	msl___light.msl_distance = msl__state_light_distance;
	msl___light.msl_dot_nl = msl__state_light_dot_nl;
	msl___light.msl_raw_contribution = msl_Light_directional_1_result;
	msl___light.msl_contribution = msl_Light_directional_1_result;
	msl___light.msl_shadow = msl_Light_directional_1_light_shadow;
	msl___light.msl_count = 1;
}

void Light_directional_2_lightmain(
	inout State state,
	in float3 msl__state_light_position,
	in float3 msl__state_light_direction,
	in float4x4 msl__state_transform_internal_to_light,
	in float4x4 msl__state_transform_light_to_internal,
	out Light_iterator msl___light)
{
	float3 msl__state_light_to_surface = (state.position) - msl__state_light_position;
	float msl__state_light_distance = length(msl__state_light_to_surface);
	msl__state_light_to_surface /= msl__state_light_distance;
	float msl__state_light_dot_nl = dot((-msl__state_light_direction), (state.normal));
	float4 msl_Light_directional_2_result;
	float4 msl_Light_directional_2_light_shadow;
	Light_directional_main(state, float4(msl_Light_directional_2_color,1), msl_Light_directional_2_intensity, msl_Light_directional_2_result, msl_Light_directional_2_light_shadow, msl__state_transform_internal_to_light, msl__state_transform_light_to_internal);
	msl___light.msl_point = msl__state_light_position;
	msl___light.msl_direction = (-msl__state_light_direction);
	msl___light.msl_distance = msl__state_light_distance;
	msl___light.msl_dot_nl = msl__state_light_dot_nl;
	msl___light.msl_raw_contribution = msl_Light_directional_2_result;
	msl___light.msl_contribution = msl_Light_directional_2_result;
	msl___light.msl_shadow = msl_Light_directional_2_light_shadow;
	msl___light.msl_count = 1;
}

void Light_directional_3_lightmain(
	inout State state,
	in float3 msl__state_light_position,
	in float3 msl__state_light_direction,
	in float4x4 msl__state_transform_internal_to_light,
	in float4x4 msl__state_transform_light_to_internal,
	out Light_iterator msl___light)
{
	float3 msl__state_light_to_surface = (state.position) - msl__state_light_position;
	float msl__state_light_distance = length(msl__state_light_to_surface);
	msl__state_light_to_surface /= msl__state_light_distance;
	float msl__state_light_dot_nl = dot((-msl__state_light_direction), (state.normal));
	float4 msl_Light_directional_3_result;
	float4 msl_Light_directional_3_light_shadow;
	Light_directional_main(state, float4(msl_Light_directional_3_color,1), msl_Light_directional_3_intensity, msl_Light_directional_3_result, msl_Light_directional_3_light_shadow, msl__state_transform_internal_to_light, msl__state_transform_light_to_internal);
	msl___light.msl_point = msl__state_light_position;
	msl___light.msl_direction = (-msl__state_light_direction);
	msl___light.msl_distance = msl__state_light_distance;
	msl___light.msl_dot_nl = msl__state_light_dot_nl;
	msl___light.msl_raw_contribution = msl_Light_directional_3_result;
	msl___light.msl_contribution = msl_Light_directional_3_result;
	msl___light.msl_shadow = msl_Light_directional_3_light_shadow;
	msl___light.msl_count = 1;
}

void Light_point_main(
	inout State state,
	float4 msl_color,
	float msl_intensity,
	float msl_distance_falloff_exponent,
	float msl_distance_scale,
	out float4 msl_result,
	out float4 msl_light_shadow,
	inout float4x4 msl__state_transform_internal_to_light,
	inout float msl__state_light_distance,
	inout float4x4 msl__state_transform_light_to_internal)
{
	{
		float msl_attenuation = 1.0;
		if (msl_distance_falloff_exponent > (float(0)))
		{
			msl_attenuation = (pow((msl__state_light_distance * msl_distance_scale), (-msl_distance_falloff_exponent)));
		}
		msl_result = (float4((((float4(msl_color)) * msl_intensity) * msl_attenuation)));
		msl_light_shadow = (float4(1,1,1,1));
	}
}

void Light_point_1_lightmain(
	inout State state,
	in float3 msl__state_light_position,
	in float4x4 msl__state_transform_internal_to_light,
	in float4x4 msl__state_transform_light_to_internal,
	out Light_iterator msl___light)
{
	float3 msl__state_light_to_surface = (state.position) - msl__state_light_position;
	float msl__state_light_distance = length(msl__state_light_to_surface);
	msl__state_light_to_surface /= msl__state_light_distance;
	float msl__state_light_dot_nl = dot((-msl__state_light_to_surface), (state.normal));
	float4 msl_Light_point_1_result;
	float4 msl_Light_point_1_light_shadow;
	Light_point_main(state, float4(msl_Light_point_1_color,1), msl_Light_point_1_intensity, msl_Light_point_1_distance_falloff_exponent, msl_Light_point_1_distance_scale, msl_Light_point_1_result, msl_Light_point_1_light_shadow, msl__state_transform_internal_to_light, msl__state_light_distance, msl__state_transform_light_to_internal);
	msl___light.msl_point = msl__state_light_position;
	msl___light.msl_direction = (-msl__state_light_to_surface);
	msl___light.msl_distance = msl__state_light_distance;
	msl___light.msl_dot_nl = msl__state_light_dot_nl;
	msl___light.msl_raw_contribution = msl_Light_point_1_result;
	msl___light.msl_contribution = msl_Light_point_1_result;
	msl___light.msl_shadow = msl_Light_point_1_light_shadow;
	msl___light.msl_count = 1;
}

void Light_point_2_lightmain(
	inout State state,
	in float3 msl__state_light_position,
	in float4x4 msl__state_transform_internal_to_light,
	in float4x4 msl__state_transform_light_to_internal,
	out Light_iterator msl___light)
{
	float3 msl__state_light_to_surface = (state.position) - msl__state_light_position;
	float msl__state_light_distance = length(msl__state_light_to_surface);
	msl__state_light_to_surface /= msl__state_light_distance;
	float msl__state_light_dot_nl = dot((-msl__state_light_to_surface), (state.normal));
	float4 msl_Light_point_2_result;
	float4 msl_Light_point_2_light_shadow;
	Light_point_main(state, float4(msl_Light_point_1_color,1), msl_Light_point_2_intensity, msl_Light_point_2_distance_falloff_exponent, msl_Light_point_2_distance_scale, msl_Light_point_2_result, msl_Light_point_2_light_shadow, msl__state_transform_internal_to_light, msl__state_light_distance, msl__state_transform_light_to_internal);
	msl___light.msl_point = msl__state_light_position;
	msl___light.msl_direction = (-msl__state_light_to_surface);
	msl___light.msl_distance = msl__state_light_distance;
	msl___light.msl_dot_nl = msl__state_light_dot_nl;
	msl___light.msl_raw_contribution = msl_Light_point_2_result;
	msl___light.msl_contribution = msl_Light_point_2_result;
	msl___light.msl_shadow = msl_Light_point_2_light_shadow;
	msl___light.msl_count = 1;
}

void Light_point_3_lightmain(
	inout State state,
	in float3 msl__state_light_position,
	in float4x4 msl__state_transform_internal_to_light,
	in float4x4 msl__state_transform_light_to_internal,
	out Light_iterator msl___light)
{
	float3 msl__state_light_to_surface = (state.position) - msl__state_light_position;
	float msl__state_light_distance = length(msl__state_light_to_surface);
	msl__state_light_to_surface /= msl__state_light_distance;
	float msl__state_light_dot_nl = dot((-msl__state_light_to_surface), (state.normal));
	float4 msl_Light_point_3_result;
	float4 msl_Light_point_3_light_shadow;
	Light_point_main(state, float4(msl_Light_point_1_color,1), msl_Light_point_3_intensity, msl_Light_point_3_distance_falloff_exponent, msl_Light_point_3_distance_scale, msl_Light_point_3_result, msl_Light_point_3_light_shadow, msl__state_transform_internal_to_light, msl__state_light_distance, msl__state_transform_light_to_internal);
	msl___light.msl_point = msl__state_light_position;
	msl___light.msl_direction = (-msl__state_light_to_surface);
	msl___light.msl_distance = msl__state_light_distance;
	msl___light.msl_dot_nl = msl__state_light_dot_nl;
	msl___light.msl_raw_contribution = msl_Light_point_3_result;
	msl___light.msl_contribution = msl_Light_point_3_result;
	msl___light.msl_shadow = msl_Light_point_3_light_shadow;
	msl___light.msl_count = 1;
}

void TGA_PhysicallBasedLighting_Shader_Ext_normalized_blinnphong_main(
	inout State state,
	float4 msl_albedo,
	float4 msl_Substance,
	float msl_Roughness,
	float AO,
	out float4 msl_result)
{
	{
		Light_iterator msl_light;
		{
			Light_directional_1_lightmain(state, float3(0.0, 0.0, 0.0), Directional1_Direction, msl_light0_transform_internal_to_light, msl_light0_transform_light_to_internal, msl_light);
			{
				float msl_ap = pow((float(256)), msl_Roughness);
				float3 msl_halfVec = normalize(((normalize(msl_light.msl_direction)) + (normalize((-(state.direction))))));
				float msl_LdotH = dot((normalize(msl_light.msl_direction)), msl_halfVec);
				float msl_NdotH = dot((normalize((state.normal))), msl_halfVec);
				float4 msl_fresnel = float4(((float4(msl_Substance)) + (((float(1)) - (float4(msl_Substance))) * (pow(((float(1)) - msl_LdotH), (float(5)))))));
				float4 msl_spec = float4(((((((float(2)) + msl_ap) / (float(8))) * (float4(msl_fresnel))) * (pow((saturate(msl_NdotH)), msl_ap))) * ((float4(msl_light.msl_contribution)) * (saturate(msl_light.msl_dot_nl)))));
				float4 msl_diffusevalue = float4((((float4(msl_albedo)) * (saturate(msl_light.msl_dot_nl))) * (float4(msl_light.msl_contribution))));
				msl_result += msl_spec * AO;
				msl_result += msl_diffusevalue;
			}
			Light_directional_2_lightmain(state, float3(0.0, 0.0, 0.0), Directional2_Direction, msl_light1_transform_internal_to_light, msl_light1_transform_light_to_internal, msl_light);
			{
				float msl_ap = pow((float(256)), msl_Roughness);
				float3 msl_halfVec = normalize(((normalize(msl_light.msl_direction)) + (normalize((-(state.direction))))));
				float msl_LdotH = dot((normalize(msl_light.msl_direction)), msl_halfVec);
				float msl_NdotH = dot((normalize((state.normal))), msl_halfVec);
				float4 msl_fresnel = float4(((float4(msl_Substance)) + (((float(1)) - (float4(msl_Substance))) * (pow(((float(1)) - msl_LdotH), (float(5)))))));
				float4 msl_spec = float4(((((((float(2)) + msl_ap) / (float(8))) * (float4(msl_fresnel))) * (pow((saturate(msl_NdotH)), msl_ap))) * ((float4(msl_light.msl_contribution)) * (saturate(msl_light.msl_dot_nl)))));
				float4 msl_diffusevalue = float4((((float4(msl_albedo)) * (saturate(msl_light.msl_dot_nl))) * (float4(msl_light.msl_contribution))));
				msl_result += msl_spec * AO;
				msl_result += msl_diffusevalue;
			}
			Light_directional_3_lightmain(state, float3(0.0, 0.0, 0.0), Directional3_Direction, msl_light2_transform_internal_to_light, msl_light2_transform_light_to_internal, msl_light);
			{
				float msl_ap = pow((float(256)), msl_Roughness);
				float3 msl_halfVec = normalize(((normalize(msl_light.msl_direction)) + (normalize((-(state.direction))))));
				float msl_LdotH = dot((normalize(msl_light.msl_direction)), msl_halfVec);
				float msl_NdotH = dot((normalize((state.normal))), msl_halfVec);
				float4 msl_fresnel = float4(((float4(msl_Substance)) + (((float(1)) - (float4(msl_Substance))) * (pow(((float(1)) - msl_LdotH), (float(5)))))));
				float4 msl_spec = float4(((((((float(2)) + msl_ap) / (float(8))) * (float4(msl_fresnel))) * (pow((saturate(msl_NdotH)), msl_ap))) * ((float4(msl_light.msl_contribution)) * (saturate(msl_light.msl_dot_nl)))));
				float4 msl_diffusevalue = float4((((float4(msl_albedo)) * (saturate(msl_light.msl_dot_nl))) * (float4(msl_light.msl_contribution))));
				msl_result += msl_spec * AO;
				msl_result += msl_diffusevalue;
			}
			Light_point_1_lightmain(state, Point1_Position, msl_light3_transform_internal_to_light, msl_light3_transform_light_to_internal, msl_light);
			{
				float msl_ap = pow((float(256)), msl_Roughness);
				float3 msl_halfVec = normalize(((normalize(msl_light.msl_direction)) + (normalize((-(state.direction))))));
				float msl_LdotH = dot((normalize(msl_light.msl_direction)), msl_halfVec);
				float msl_NdotH = dot((normalize((state.normal))), msl_halfVec);
				float4 msl_fresnel = float4(((float4(msl_Substance)) + (((float(1)) - (float4(msl_Substance))) * (pow(((float(1)) - msl_LdotH), (float(5)))))));
				float4 msl_spec = float4(((((((float(2)) + msl_ap) / (float(8))) * (float4(msl_fresnel))) * (pow((saturate(msl_NdotH)), msl_ap))) * ((float4(msl_light.msl_contribution)) * (saturate(msl_light.msl_dot_nl)))));
				float4 msl_diffusevalue = float4((((float4(msl_albedo)) * (saturate(msl_light.msl_dot_nl))) * (float4(msl_light.msl_contribution))));
				msl_result += msl_spec * AO;
				msl_result += msl_diffusevalue;
			}
			Light_point_2_lightmain(state, Point2_Position, msl_light4_transform_internal_to_light, msl_light4_transform_light_to_internal, msl_light);
			{
				float msl_ap = pow((float(256)), msl_Roughness);
				float3 msl_halfVec = normalize(((normalize(msl_light.msl_direction)) + (normalize((-(state.direction))))));
				float msl_LdotH = dot((normalize(msl_light.msl_direction)), msl_halfVec);
				float msl_NdotH = dot((normalize((state.normal))), msl_halfVec);
				float4 msl_fresnel = float4(((float4(msl_Substance)) + (((float(1)) - (float4(msl_Substance))) * (pow(((float(1)) - msl_LdotH), (float(5)))))));
				float4 msl_spec = float4(((((((float(2)) + msl_ap) / (float(8))) * (float4(msl_fresnel))) * (pow((saturate(msl_NdotH)), msl_ap))) * ((float4(msl_light.msl_contribution)) * (saturate(msl_light.msl_dot_nl)))));
				float4 msl_diffusevalue = float4((((float4(msl_albedo)) * (saturate(msl_light.msl_dot_nl))) * (float4(msl_light.msl_contribution))));
				msl_result += msl_spec * AO;
				msl_result += msl_diffusevalue;
			}
			Light_point_3_lightmain(state, Point3_Position, msl_light5_transform_internal_to_light, msl_light5_transform_light_to_internal, msl_light);
			{
				float msl_ap = pow((float(256)), msl_Roughness);
				float3 msl_halfVec = normalize(((normalize(msl_light.msl_direction)) + (normalize((-(state.direction))))));
				float msl_LdotH = dot((normalize(msl_light.msl_direction)), msl_halfVec);
				float msl_NdotH = dot((normalize((state.normal))), msl_halfVec);
				float4 msl_fresnel = float4(((float4(msl_Substance)) + (((float(1)) - (float4(msl_Substance))) * (pow(((float(1)) - msl_LdotH), (float(5)))))));
				float4 msl_spec = float4(((((((float(2)) + msl_ap) / (float(8))) * (float4(msl_fresnel))) * (pow((saturate(msl_NdotH)), msl_ap))) * ((float4(msl_light.msl_contribution)) * (saturate(msl_light.msl_dot_nl)))));
				float4 msl_diffusevalue = float4((((float4(msl_albedo)) * (saturate(msl_light.msl_dot_nl))) * (float4(msl_light.msl_contribution))));
				msl_result += msl_spec * AO;
				msl_result += msl_diffusevalue;
			}
		}
		msl_result.a = msl_albedo.a;
	}
}

void TGA_PhysicallBasedLighting_Shader_AmbientCube_Conversion_float_to_color_main(
	inout State state,
	float msl_scalar,
	out float4 msl_color)
{
	{
		msl_color = (float4(msl_scalar, msl_scalar, msl_scalar, 1.0));
	}
}

void TGA_PhysicallBasedLighting_Shader_AmbientCube_State_normal_main(
	inout State state,
	out float3 msl_result)
{
	{
		msl_result = (state.normal);
	}
}

void TGA_PhysicallBasedLighting_Shader_AmbientCube_Transform_internal_to_world_normal_main(
	inout State state,
	float3 msl_norm,
	out float3 msl_result)
{
	{
		msl_result = (mul(msl_norm, (float3x3)__world_to_camera));
	}
}

void TGA_PhysicallBasedLighting_Shader_AmbientCube_Conversion_float3_to_floats_main(
	inout State state,
	float3 msl_vector,
	out float msl_x,
	out float msl_y,
	out float msl_z)
{
	{
		msl_x = msl_vector.x;
		msl_y = msl_vector.y;
		msl_z = msl_vector.z;
	}
}

void TGA_PhysicallBasedLighting_Shader_AmbientCube_Conversion_floats_to_float3_main(
	inout State state,
	float msl_x,
	float msl_y,
	float msl_z,
	out float3 msl_result)
{
	{
		msl_result = (float3(msl_x, msl_y, msl_z));
	}
}

void TGA_PhysicallBasedLighting_Shader_AmbientCube_Ext_cube_mip_main(
	inout State state,
	samplerCUBE msl_texture,
	int msl_texture_space,
	float3 msl_texture_uvw,
	out float4 msl_result)
{
	{
		msl_result = (texCUBElod(msl_texture, float4(msl_texture_uvw.xzy,Ambient_Mip_Level)));
	}
}

void TGA_PhysicallBasedLighting_Shader_AmbientCube_Math_color_multiply_main(
	inout State state,
	float4 msl_left,
	float4 msl_right,
	out float4 msl_result)
{
	{
		msl_result = (float4(((float4(msl_left)) * (float4(msl_right)))));
	}
}

void TGA_PhysicallBasedLighting_Shader_AmbientCube_main(
	inout State state,
	samplerCUBE msl_EnvironmentTexture,
	float3 msl_NormalMapInput,
	float msl_Environment_Intensity,
	float4 msl_AlbedoInput,
	out float4 msl_result)
{
	{
		float4 msl_Conversion_float_to_color_2_color;
		TGA_PhysicallBasedLighting_Shader_AmbientCube_Conversion_float_to_color_main(state, msl_Environment_Intensity, msl_Conversion_float_to_color_2_color);
		float3 msl_State_normal_1_result;
		{
			float3 msl__normal_temp = state.normal;
			(state.normal) = msl_NormalMapInput;
			TGA_PhysicallBasedLighting_Shader_AmbientCube_State_normal_main(state, msl_State_normal_1_result);
			(state.normal) = msl__normal_temp;
		}
		float3 msl_Transform_internal_to_world_normal_1_result;
		TGA_PhysicallBasedLighting_Shader_AmbientCube_Transform_internal_to_world_normal_main(state, msl_State_normal_1_result, msl_Transform_internal_to_world_normal_1_result);
		float msl_Conversion_float3_to_floats_1_x;
		float msl_Conversion_float3_to_floats_1_y;
		float msl_Conversion_float3_to_floats_1_z;
		TGA_PhysicallBasedLighting_Shader_AmbientCube_Conversion_float3_to_floats_main(state, msl_Transform_internal_to_world_normal_1_result, msl_Conversion_float3_to_floats_1_x, msl_Conversion_float3_to_floats_1_y, msl_Conversion_float3_to_floats_1_z);
		float3 msl_Conversion_floats_to_float3_1_result;
		TGA_PhysicallBasedLighting_Shader_AmbientCube_Conversion_floats_to_float3_main(state, msl_Conversion_float3_to_floats_1_x, msl_Conversion_float3_to_floats_1_z, msl_Conversion_float3_to_floats_1_y, msl_Conversion_floats_to_float3_1_result);
		float4 msl_AmbientCube_result;
		TGA_PhysicallBasedLighting_Shader_AmbientCube_Ext_cube_mip_main(state, msl_EnvironmentTexture, 0, msl_Conversion_floats_to_float3_1_result, msl_AmbientCube_result);
		float4 msl_Math_color_multiply_5_result;
		TGA_PhysicallBasedLighting_Shader_AmbientCube_Math_color_multiply_main(state, msl_AlbedoInput, msl_AmbientCube_result, msl_Math_color_multiply_5_result);
		float4 msl_Math_color_multiply_4_result;
		TGA_PhysicallBasedLighting_Shader_AmbientCube_Math_color_multiply_main(state, msl_Conversion_float_to_color_2_color, msl_Math_color_multiply_5_result, msl_Math_color_multiply_4_result);
		msl_result = msl_Math_color_multiply_4_result;
	}
}

void TGA_PhysicallBasedLighting_Shader_ReflectionCube_Ext_reflection_fresnel_main(
	inout State state,
	float4 msl_Substance,
	out float4 msl_result)
{
	{
		float msl_NdotV = dot((normalize((state.normal))), (normalize((-(state.direction)))));
		float4 msl_fresnel = float4(((float4(msl_Substance)) + (((float(1)) - (float4(msl_Substance))) * (pow(((float(1)) - msl_NdotV), (float(5)))))));
		msl_result = msl_fresnel;
	}
}

void Environment_map_cubic_mip_main(
	inout State state,
	samplerCUBE msl_env_tex,
	float msl_intensity,
	sampler2D msl_texture,
	out float4 msl_result,
	inout float3 msl__state_direction)
{
	{
		float roughness;
		roughness = tex2D(msl_texture,state.tex_coord[0].xy).r;
		
		float3 msl_v = mul((float3x3)__camera_to_world, msl__state_direction);
//		float3 pow_cube = float3(pow((texCUBE(msl_env_tex,msl_v.xyz).r),2.2),pow((texCUBE(msl_env_tex,msl_v.xyz).g),2.2),pow((texCUBE(msl_env_tex,msl_v.xyz).b),2.2));

		msl_result = (texCUBElod((msl_env_tex), float4(msl_v.xyz,(((Reflection_Max_Mip_Level)-(Reflection_Max_Mip_Level * roughness))))));
		msl_result *= msl_intensity;
// Manuell Gamma-korrigering. Korrekt att köra på result här?
		msl_result = pow(msl_result,2.2);
	}
}

void Environment_map_cubic_mip_1_environmentmain(
	inout State state,
	in float3 msl__state_direction,
	out float4 msl___result)
{
	float4 msl_Environment_map_cubic_mip_1_result;
	Environment_map_cubic_mip_main(state, Environment_Cube_Gamma, float(1.0), Roughness_Texture_Gamma, msl_Environment_map_cubic_mip_1_result, msl__state_direction);
	msl___result = msl_Environment_map_cubic_mip_1_result;
}

float4 __trace_environment(
	inout State state,
	Ray msl_ray)
{
	float4 msl_result;
	Environment_map_cubic_mip_1_environmentmain(state, msl_ray.msl_direction, msl_result);
	return msl_result;
}

void TGA_PhysicallBasedLighting_Shader_ReflectionCube_Component_reflection_main(
	inout State state,
	out float4 msl_result)
{
	{
		float3 msl_reflected = reflect((state.direction), (state.normal));
//		if ((dot(msl_reflected, (state.geom_normal))) < 0.0)
//		{
//			msl_reflected = (reflect((state.direction), (state.geom_normal)));
//		}
		msl_result = (float4(0.0));
		Ray msl_ray = Ray((state.position), msl_reflected);
		Ray msl_ray_dx = Ray((float3((float(0)))), (float3((float(0)))));
		Ray msl_ray_dy = Ray((float3((float(0)))), (float3((float(0)))));
		int msl_trace_opt = 13;
		msl_trace_opt = 13;
		if (!(((((msl_trace_opt == 3) || (msl_trace_opt == 13)) || (msl_trace_opt == 12)) || (msl_trace_opt == 11)) ? (((msl_result = (__trace_environment(state, msl_ray))), true)) : false))
		{
			msl_trace_opt = 3;
			((((msl_trace_opt == 3) || (msl_trace_opt == 13)) || (msl_trace_opt == 12)) || (msl_trace_opt == 11)) ? (((msl_result = (__trace_environment(state, msl_ray))), true)) : false;
		}
	}
}

void TGA_PhysicallBasedLighting_Shader_ReflectionCube_Math_color_multiply_main(
	inout State state,
	float4 msl_left,
	float4 msl_right,
	out float4 msl_result)
{
	{
		msl_result = (float4(((float4(msl_left)) * (float4(msl_right)))));
	}
}

void TGA_PhysicallBasedLighting_Shader_ReflectionCube_main(
	inout State state,
	float4 msl_SubstanceInput,
	float3 msl_Inputs_1_Normal,
	out float4 msl_result)
{
	{
		float4 msl_Ext_reflection_fresnel_1_result;
		TGA_PhysicallBasedLighting_Shader_ReflectionCube_Ext_reflection_fresnel_main(state, msl_SubstanceInput, msl_Ext_reflection_fresnel_1_result);
		float4 msl_Component_reflection_1_result;
		float3 msl__normal_temp = state.normal;
		(state.normal) = msl_Inputs_1_Normal;		
		TGA_PhysicallBasedLighting_Shader_ReflectionCube_Component_reflection_main(state, msl_Component_reflection_1_result);
		(state.normal) = msl__normal_temp;
		float4 msl_Math_color_multiply_2_result;
		TGA_PhysicallBasedLighting_Shader_ReflectionCube_Math_color_multiply_main(state, msl_Ext_reflection_fresnel_1_result, msl_Component_reflection_1_result, msl_Math_color_multiply_2_result);
		msl_result = msl_Math_color_multiply_2_result;
	}
}

void TGA_PhysicallBasedLighting_Shader_Math_color_add_main(
	inout State state,
	float4 msl_left,
	float4 msl_right,
	out float4 msl_result)
{
	{
		msl_result = (float4(((float4(msl_left)) + (float4(msl_right)))));
	}
}

void TGA_PhysicallBasedLighting_Shader_Math_color_multiply_main(
	inout State state,
	float4 msl_left,
	float4 msl_right,
	out float4 msl_result)
{
	{
		msl_result = (float4(((float4(msl_left)) * (float4(msl_right)))));
	}
}

void TGA_PhysicallBasedLighting_Shader_Math_float_divide_main(
	inout State state,
	float msl_left,
	float msl_right,
	out float msl_result)
{
	{
		msl_result = (msl_left / msl_right);
	}
}

void TGA_PhysicallBasedLighting_Shader_Math_color_pow_main(
	inout State state,
	float4 msl_base,
	float4 msl_exponent,
	out float4 msl_result)
{
	{
		msl_result = (float4((pow((float4(msl_base)), (float4(msl_exponent))))));
	}
}

void TGA_PhysicallBasedLighting_Shader_main(
	inout State state,
	sampler2D msl_AlbedoTexture,
	sampler2D msl_NormalTexture,
	sampler2D msl_AOTexture,
	sampler2D msl_RoughnessTexture,
	sampler2D msl_SubstanceTexture,
	float msl_ReflectionMaxMip,
	float msl_Exposure,
	samplerCUBE msl_AmbEnvTex,
	out float4 msl_result)
{
	{
		float4 msl_SimpleExposure_color;
		TGA_PhysicallBasedLighting_Shader_Conversion_float_to_color_main(state, msl_Exposure, msl_SimpleExposure_color);
		float4 msl_Inputs_1_Albedo;
		float3 msl_Inputs_1_Normal;
		float msl_Inputs_1_AO;
		float msl_Inputs_1_Roughness;
		float4 msl_Inputs_1_Substance;
		TGA_PhysicallBasedLighting_Shader_Inputs_main(state, msl_AlbedoTexture, msl_NormalTexture, msl_AOTexture, msl_RoughnessTexture, msl_SubstanceTexture, msl_Inputs_1_Albedo, msl_Inputs_1_Normal, msl_Inputs_1_AO, msl_Inputs_1_Roughness, msl_Inputs_1_Substance);
		float4 msl_Ext_normalized_blinnphong_1_result;
		{
			float3 msl__normal_temp = state.normal;
			(state.normal) = msl_Inputs_1_Normal;
			TGA_PhysicallBasedLighting_Shader_Ext_normalized_blinnphong_main(state, msl_Inputs_1_Albedo, msl_Inputs_1_Substance, msl_Inputs_1_Roughness, msl_Inputs_1_AO, msl_Ext_normalized_blinnphong_1_result);
			(state.normal) = msl__normal_temp;
		}
		float4 msl_AO_float_to_color_color;
		TGA_PhysicallBasedLighting_Shader_Conversion_float_to_color_main(state, msl_Inputs_1_AO, msl_AO_float_to_color_color);
		float4 msl_AmbientCube_1_result;
		{
			float3 msl__normal_temp = state.normal;
			TGA_PhysicallBasedLighting_Shader_AmbientCube_main(state, msl_AmbEnvTex, msl_Inputs_1_Normal, float(1.0), msl_Inputs_1_Albedo, msl_AmbientCube_1_result);
			(state.normal) = msl__normal_temp;
		}
		float4 msl_ReflectionCube_1_result;
		TGA_PhysicallBasedLighting_Shader_ReflectionCube_main(state, msl_Inputs_1_Substance, msl_Inputs_1_Normal, msl_ReflectionCube_1_result);
		float4 msl_Math_color_add_1_result;
		TGA_PhysicallBasedLighting_Shader_Math_color_add_main(state, msl_AmbientCube_1_result, msl_ReflectionCube_1_result, msl_Math_color_add_1_result);
		float4 msl_Math_color_multiply_1_result;
		TGA_PhysicallBasedLighting_Shader_Math_color_multiply_main(state, msl_AO_float_to_color_color, msl_Math_color_add_1_result, msl_Math_color_multiply_1_result);
		float4 msl_Math_color_add_2_result;
		TGA_PhysicallBasedLighting_Shader_Math_color_add_main(state, msl_Ext_normalized_blinnphong_1_result, msl_Math_color_multiply_1_result, msl_Math_color_add_2_result);
		float msl_Math_float_divide_1_result;
		TGA_PhysicallBasedLighting_Shader_Math_float_divide_main(state, 1.0, 2.200000, msl_Math_float_divide_1_result);
		float4 msl_Conversion_float_to_color_1_color;
		TGA_PhysicallBasedLighting_Shader_Conversion_float_to_color_main(state, msl_Math_float_divide_1_result, msl_Conversion_float_to_color_1_color);
		float4 msl_Math_color_pow_1_result;
		TGA_PhysicallBasedLighting_Shader_Math_color_pow_main(state, msl_Math_color_add_2_result, msl_Conversion_float_to_color_1_color, msl_Math_color_pow_1_result);
		float4 msl_Math_color_multiply_3_result;
		TGA_PhysicallBasedLighting_Shader_Math_color_multiply_main(state, msl_SimpleExposure_color, msl_Math_color_pow_1_result, msl_Math_color_multiply_3_result);
		msl_result = msl_Math_color_multiply_3_result;
	}
}

//
// The following method is the root function of the shader graph
//
float4 TGA_PhysicallBasedLighting_Shader_1_eval(State state, out FS_OUT eval_out)
{
	// primary_out: 
	float4 msl_result;
	{
		float3 msl__normal_temp = state.normal;
		TGA_PhysicallBasedLighting_Shader_main(state, Albedo_Texture_Gamma, Normal_Texture_Linear, AO_Texture_Gamma, Roughness_Texture_Gamma, Substance_Texture_Gamma, Reflection_Max_Mip_Level, Exposure, Environment_Cube_Gamma, msl_result);
		(state.normal) = msl__normal_temp;
	}
	eval_out = float4(msl_result);
	return float4(msl_result);
}

//
// This function is the main method of the fragment shader. It initializes the
// values in the state structure that are used by nodes in the shader graph
// and produces the final result of the shader.
//
FS_OUT fragment_main(
	Vert2frag fs_in) : COLOR
{
	State state;
	state.position = fs_in.position;
	state.normal = normalize(fs_in.normal);
	state.geom_normal = state.normal;
	state.tex_coord = fs_in.tex_coord;
	state.origin = 0;
	state.ray_length = length(state.position);
	state.direction = state.position/state.ray_length;
	float3 t_tex_tangent, t_tex_binormal;
	__make_basis(state.normal, fs_in.tex_du, fs_in.tex_dv, t_tex_tangent, t_tex_binormal);
	state.tangent_space[0] = float3x3(
	    t_tex_tangent,
	    t_tex_binormal,
	    state.normal);

	FS_OUT eval_out;  // multiple shader outputs
	float4 primary_out;  // primary shader output
	primary_out = TGA_PhysicallBasedLighting_Shader_1_eval(state, eval_out);
	FS_OUT fs_out;
	fs_out = primary_out;
	return fs_out;
}

//
// The following define the default technique and pass of the effect.
//
technique StandardTechnique
{
	pass P0
	{
		DepthTestEnable = true;
		DepthMask       = true;
		CullFaceEnable  = false;
		VertexShader = compile vp40 vertex_main();
		PixelShader  = compile fp40 fragment_main();
	}
}

string description = "TGA Physically Based Lighting Shader v0.2.1";